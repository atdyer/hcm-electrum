module hcm

open util/graph [Joint]

sig Joint {
	neighbors: some Joint,
	var pending: set Joint
}

sig fixed in Joint {}
var sig balanced in Joint {}
var sig converged in Joint {}

fact topology {
	noSelfLoops[neighbors]
	undirected[neighbors]
	stronglyConnected[neighbors]
}

fact pending_in_neighbors {
	always all u: Joint {
		u.pending in u.neighbors
	}
}

fact converged_must_be_balanced {
	always all u: Joint {
		u in converged => u in balanced
	}
}

----------------------------------------

pred init {
	-- start with no balanced joints
	no balanced

	-- start with no pending moment carryovers
	all u: Joint | no u.pending
}

pred step {
	stutter
	or (some u: Joint | release_and_distribute[u])
	or (some u, v: Joint | carryover[u, v])
}

pred stutter {

	pending' = pending
	balanced' = balanced
	converged' = converged

}

pred release_and_distribute [u: Joint] {

	-- u is not fixed or balanced
	u not in fixed
	u not in balanced

	-- there are no pending carryovers away from u
	no u.pending

	-- only u may change balanced state, and it becomes balanced
	balanced' = balanced + u

	-- only carryovers originating at u may change pending state,
	-- and they all acquire a pending moment carryover
	pending' = pending + u <: neighbors

	-- converged state does not change
	converged' = converged

}

pred carryover [u, v: Joint] {

	-- there is a pending moment carryover from u to v
	u->v in pending

	-- in the next state there is no longer a pending carryover
	-- from u to v, and all other pending states remain the same
	pending' = pending - u->v

	-- only v may change balanced state, all others remain unchanged
	(balanced' = balanced + v or balanced' = balanced - v)

	-- only v may change converged state, all others remain unchanged
	(converged' = converged + v or converged' = converged - v)

}

----------------------------------------

-- enforce at least two adjacent non-fixed joints, at least one of
-- which is not balanced
fact iterable_topologies {
	some u, v: Joint {
		u->v in neighbors
		u not in fixed
		v not in fixed
		(u not in balanced or v not in balanced)
	}
}

fact traces {
	init
	always step
}

----------------------------------------

pred can_release_and_distribute {
	some u: Joint {
		u not in fixed
		u not in balanced
		no u.pending
	}
}

pred can_carry {
	some u, v: Joint {
		u->v in pending
	}
}

pred fairness {
	
	-- if a release and balance is possible, it will
	-- eventually happen
	always {
		can_release_and_distribute => eventually { 
			some u: Joint | release_and_distribute[u] 
		}
	}

	-- if a carryover is possible, it will eventually
	-- happen
	always {
		can_carry => eventually { 
			some u, v: Joint | carryover[u, v] 
		}
	}

	-- as long as the model is not converged, we'll
	-- eventually not stutter
	always {
		not model_converged => eventually {
			not stutter
		}
	}


}

pred vertices_converge {

	-- eventually, for all possible carryovers, carryover results
	-- in a converged state. this implies that at some point a
	-- carryover from u to v will never unbalance the joint v
	eventually { 
		all u, v: Joint { 
			always (carryover[u, v] => converged' = converged + v)
		}
	}
}

pred model_converged {

	-- there are no pending moment carryovers
	no pending

	-- all joints are converged (and thus balanced)
	converged = Joint

}

--
-- check that the model will converge
--

assert convergence {
	(fairness and vertices_converge) => eventually model_converged
}

check convergence for 6


--
-- show a converging model
--

pred show {
	fairness and vertices_converge
}

run show for 3


--
-- show a model in which every joint goes from balanced
-- to unbalanced at some point
--

pred show_iteration {
	fairness
	vertices_converge
	all u: Joint {
		eventually { u in balanced and u not in balanced' }
	}
}

-- Time = (4 * #joint) + 1
run show_iteration for 3 but exactly 2 Joint
run show_iteration for 3 but exactly 3 Joint, exactly 13 Time
run show_iteration for 3 but exactly 4 Joint, exactly 17 Time

